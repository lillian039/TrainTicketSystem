# 火车票管理系统后端部分

文档作者：胡珂雅 肖景琦

版本：1.0

## **组内分工**

- B+树：胡珂雅
- 火车票主体：肖景琦
- 前端：胡珂雅 肖景琦

## 一、程序功能概述

**实现一个火车票系统，实现功能为：**

- 用户：存储用户信息、修改、添加用户

- 车次：存储车次信息、删除车次、修改车次信息

- 订单：存储用户订单、购票退票、存储车次每天每站余票量、订单候补队列

**预计实现bonus：**

- 前端
- B+树空间回收
- 添加缓存
- 命令行交互扩展

## 二、主体逻辑说明

- **文件读写部分：**

  - 索引：由b+树实现，包括两个文件，一个存节点，一个存叶子，由 `bptree.hpp` 实现
  - 总数据库：由b+树键值对应的地址查找，由 `database.hpp` 实现
  - 添加缓存：在b+树默认构造函数中将常用节点导入内存中
  - 空间回收：由一个在文件中的单向链表实现
  - 回滚：由一个文件按顺序记录所有指令

- **主体逻辑部分：**

  - `main.cpp`：运行文件，接受指令，处理异常

  - `parser.hpp`：解析指令，并分配给不同 $hpp$ 文件执行指令

  - `system.hpp`：执行系统指令

  - `user.hpp`：执行用户类相关指令

    - 用户池利用map进行维护
    - 用户信息直接用一个B+树索引文件维护

  - `train.hpp`：执行车次类相关指令

    - 列车基本信息由B+树与列车信息数据库维护：` id->index1 `，`index_1->车次详细信息`

    - 每个列车的所有订单由B+树与列车订单数据库维护： `id->index2` ，`index2->100天订单详细信息`，用于指令`query_train`

      一个B+树维护经过某车站的所有车次的信息库下标 `index1` ，用于查询两地间车票`query_ticket`，`query_transfer`

  - `order.hpp`：执行订单类相关指令

    - 用户订单信息由B+树`user_id->order`维护
    - 火车候补队列由B+树`train_id+time->order`维护

- **异常处理：**
  - 用 `error.hpp`处理各种异常，并反馈给用户，实现命令行交互拓展

## 三、实现的具体说明

- `main.cpp`：运行文件，接受异常

  ```c++
  #include <iostream>
  #include "parser.hpp"
  
  int main() {
      std::string commandLine;
      while (true) {
          try {
              getline(cin, commandLine);
              if (cin.eof())std::exit(0);
              parseCommand(commandLine);
          }
          catch (my_error &ex) {
              std::cout << ex.what();
          }
      }
  }
  
  ```

  

- `parser.hpp`：解析并执行指令

  ```c++
  #ifndef PARSER_HPP
  #define PARSER_HPP
  
  #include "user.hpp"
  #include "train.hpp"
  #include "error.hpp"
  
  sjtu::vector<std::string> parser(std::string command_line){}
  
  void parse_command(std::string command_line){}
  
  #endif
  
  ```

  

- `system.hpp`：执行系统指令

  ```c++
  #ifndef SYSTEM_HPP
  #define SYSTEM_HPP
  
  #include "user.hpp"
  #include "train.hpp"
  #include "order.hpp"
  
  void rollback(){}
  
  void clean(){}
  
  void exit(){}
  
  #endif
  ```

  

- `bptree.hpp`：B+树模板

  ```c++
  #ifndef TRAINTICKETSYSTEM_BPTREE_HPP
  #define TRAINTICKETSYSTEM_BPTREE_HPP
  
  #include <iostream>
  
  template<class Key, class T, int M = 10, int L = 100>//M 阶BPT 块中数据为L
  //B+树维护索引
  //文件*2 bptree主体 leaf结构
  class BPTree {
  private:
      std::fstream file_bpt,file_leaf;
      std::pair <Key, T> value;
      std::string recyle;
      int root;//根节点所在位置 放在文件头
      int empty;//空的空间所在位置，为一个单向链表 链表头接在root后
      struct Node {
          bool is_leaf;
          int n;// n个关键字
          int A[M + 1];//大于、小于关键字的地址
          std::pair<Key, int> K[M];//关键字 与关键字所存元素所在地址
      };
  
      struct Leaf {
          int nxt;//顺序查找的下一位地址
          std::pair <Key, T> value[L];
      };
  private:
      void spiltL() {}//叶节点分裂
  
      void mergeL() {}//叶节点合并
  
      void splitN() {}//节点分裂
  
      void mergeN() {}//节点合并
  
  public:
  
      BPT(std::string name) {}
      //打开文件 + 读取根节点与第一层子节点内存中 + 打开空间回收文件
  
      BPT() = default;
  
      ~BPT() {}
      //关闭文件 + 将根节点与第一层子节点读入文件
  
      void clear() {}
      //清空bpt
  
      void insert(const std::pair <Key, T> &val) {}
      //插入键值+数据
  
      void remove(const Key &key) {}
      //通过键值删除 并进行空间回收
  
      T find(const Key &key) {}
      //一对一键值查找
  
      sjtu::vector <T> Find(const Key &key) {}
      //一对多键值查找
  
  };
  
  template<class T>//索引结构体 找到总数据库
  struct Index{
      T key;
      int idx;
  };
  
  #endif //TRAINTICKETSYSTEM_BPTREE_HPP
  ```
  
  
  
- `database.hpp`：总数据库文件读写模板

  ```c++
  #ifndef TRAINTICKETSYSTEM_DATABASE_HPP
  #define TRAINTICKETSYSTEM_DATABASE_HPP
  
  //索引指向的总数据库
  //文件*1 数据库主体 
  template<class T>
  class Database {
  private:
      T data;
      fstream file,file_recycle;
      int head,rear;//文件头尾所在位置
      int empty//空的空间所在位置 为一个单向链表
  public:
      Database() = default;
  
      Database(std::string name) {}
      //初始化 打开文件
  
      ~Database(){}
      //析构 关闭文件
  
      T find(int idx) {}
      //根据bptree索引搜到的文件位置找到数据
  
      T find(int idx,int day) {}
      //用于查找某车次车票某天的售卖情况 idx为某车次的车票所在位置
  
      void remove(int idx){}
      //根据bptree索引搜到的文件位置找到数据 并进行空间回收
  
      void insert(T value,int time=0){}
      //插入新的数据组
  };
  
  
  #endif //TRAINTICKETSYSTEM_DATABASE_HPP
  ```
  
  
  
- `user.hpp`：用户类

  ```c++
  class user{
  private:
  	string<20> username;
  	string<30> password;
  	string<15> realname;
  	string<30> mailaddr;
  	int privilege=0;
  	int hashe;
  public:
  	user(){}
  
  	user(const string<20>& _username,const string<30>& _password,
  		const string<15>& _realname,const string<30>& _mailaddr,
  		const int& _privilege){}
  
  	~user(){}
  
  	friend bool operator < (const user& lhs,const user& rhs){
  		return lhs.hashe<rhs.hashe;
  	}
  
  	friend bool operator == (const user& lhs,const user& rhs){
  		return lhs.hashe==rhs.hashe;
  	}
  
  	friend bool operator != (const user& lhs,const user& rhs){
  		return lhs.hashe!=rhs.hashe;
  	}
  
  	string<30> get_password() const {}
  
  	string<15> get_realname() const {}
  
  	string<30> get_mailaddr() const {}
  
  	int get_pribilege() const {}
  
  	void modify_password(const string<30>& _password){}
  
  	void modify_realname(const string<15>& _realname){}
  
  	void modify_mailaddr(const string<30>& _mailaddr){}
  
  	void modify_privilege(const int& _privilege){}
  };
  
  BPTtree<int,user> bpt_station_train;
  //哈希值对应用户
  
  map<int,user> log_in;
  
  void add_user(){}
  
  void login(){}
  
  void logout(){}
  
  int query_profile(){}
  
  void modify_profile(){}
  ```
  
  
  
- `train.hpp`：车次类

  ```c++
  struct station{
  	string<30> name;
  	int hashe;
  	int seatnum;
  	int price;
  	int travel_time;
  	int stop_time;
  	
  	friend bool operator < (const station& lhs,const station& rhs){
  		return lhs.hashe<rhs.hashe;
  	}
  
  	friend bool operator == (const station& lhs,const station& rhs){
  		return lhs.hashe==rhs.hashe;
  	}
  
  	friend bool operator != (const station& lhs,const station& rhs){
  		return lhs.hashe!=rhs.hashe;
  	}
  };
  
  class train{
  private:
  	string<20> trainid;
  	int station_num;
  	date start_sale;
  	date end_sale;
  	date start_time;
  	string<1> type;
  	station stations[100];
  	bool is_release=0;
  	int hashe;
  public:
  	train(){}
  	
  	~train(){}
  
  	friend bool operator < (const train& lhs,const train& rhs){
  		return lhs.hashe<rhs.hashe;
  	}
  
  	friend bool operator == (const train& lhs,const train& rhs){
  		return lhs.hashe==rhs.hashe;
  	}
  
  	friend bool operator != (const train& lhs,const train& rhs){
  		return lhs.hashe!=rhs.hashe;
  	}
  };
  
  class ticket{
  	int ticket_num[402],tag[402];
  
  	void build(){}
  	//线段树建树
  
  	void push(int k,int v){}
  	//区间维护，打标记
  	
  	void down(int k){}
  	//下放标记
  	
  	void update(int k,int l,int r,int L,int R,int v){}
  	//区间增加多少
  	
  	int query_min(int k,int l,int r,int L,int R){}
  	//区间的最小值
  
  };
  
  BPTtree<int,int> bpt_station_train;
  //每个车站的哈希值对应哪些车次id位置
  
  BPTtree<int,std::pair<int,int>> bpt_train_information;
  //每个车次的哈希值对应数据库中位置 fisrt 对应火车信息，second对应车票信息
  
  database<train> train_information;
  //找到对应的火车信息
  
  database<ticket> train_ticket;
  //找到对应的车票信息
  
  
  void add_train(){}
  
  void release_train(){}
  
  void query_train(){}
  
  void query_ticket(){}
  
  void query_transfer(){}
  ```
  
  
  
- `order.hpp`：订单类

  ```c++
  #ifndef ORDER_HPP
  #define ORDER_HPP
  
  #include "string.hpp"
  #include "date.hpp"
  #include "error.hpp"
  #include "user.hpp"
  #include "train.hpp"
  #include "bptree.hpp"
  
  class order{
  	string<20> username;
  	string<20> trainid;
  	string<15> start_station;
  	string<15> end_station;
  	int price;
  	int status;
  	//0 succeeded; 1 pending; 2 refunded
  	int ticket_num;
  	date time;
  };
  
  BPTtree<int,order> btp_user_order;
  //用户id的哈希值查询订单
  
  BPTtree<int,order> btp_train_order;
  //用户id的哈希值查询车次的候补队列
  
  void buy_ticket(){}
  
  void query_order(){}
  
  void refund_ticket(){}
  
  #endif
  ```
  
- `error.hpp`：抛出异常

  ```c++
  #ifndef ERROR_HPP
  #define ERROR_HPP
  
  class my_error{
  private:
      std::string error;
  public:
      my_error(){}
  
      my_error(const std::string& _error){}
  
      my_error(const my_error& other){}
  
      ~my_error(){}
  
      std::string what(){}
  }
  
  #endif
  ```

  

## 四、所需文件说明

- #### `BPTree` 

  共$5×2=10$个文件

  - 用户信息
  - 列车信息`id->index`
  - 车站车次`station->index`
  - 用户订单信息
  - 火车票候补队列

- #### `Database` 

  共$1×2=2$个文件

  - 列车信息`index->信息`
  - 列车订单汇总`index->三个月订单`

- #### `Roll`

  共1一个文件

  - 回滚操作，由一个顺序存储指令的文件构成

## 五、所用到Tool

`namespace sjtu`

- `vector`
- `map`
- `linkhashmap`
- `string`
- `date`

## 六、其他补充说明

- 前端与前后端连接部分暂未完成
- 实现过程中可能会对开发文档进行细节修改，但保证不会颠覆整体逻辑
